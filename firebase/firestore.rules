rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isCoupleMember(coupleId) {
      return isSignedIn() &&
        exists(/databases/$(database)/documents/couples/$(coupleId)) &&
        request.auth.uid in get(/databases/$(database)/documents/couples/$(coupleId)).data.members;
    }

    function validMessage() {
      return request.resource.data.text.size() <= 2000 &&
             request.resource.data.sender == request.auth.uid;
    }

    function isReadReceiptUpdate() {
      let rootDiff = request.resource.data.diff(resource.data);
      let readDiff = request.resource.data.readBy.diff(resource.data.readBy);
      return ('readBy' in resource.data) &&
             ('readBy' in request.resource.data) &&
             rootDiff.changedKeys().hasOnly(['readBy']) &&
             readDiff.removedKeys().hasOnly([]) &&
             readDiff.affectedKeys().hasOnly([request.auth.uid]) &&
             request.resource.data.readBy[request.auth.uid] is timestamp;
    }

    // USERS Collection - only owner can read/write
    match /users/{userId} {
      allow read: if isOwner(userId);
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) &&
        (!('uid' in request.resource.data) || request.resource.data.uid == userId);
      allow delete: if false; // Never allow user deletion from client

      // Device tokens subcollection
      match /devices/{deviceId} {
        allow read, write: if isOwner(userId);
      }
    }

    // COUPLES Collection - members only
    match /couples/{coupleId} {
      allow create: if isSignedIn() &&
        request.resource.data.ownerUid == request.auth.uid &&
        request.resource.data.members.size() <= 2 &&
        request.auth.uid in request.resource.data.members;

      allow read: if isCoupleMember(coupleId);

      allow update: if isCoupleMember(coupleId) &&
        request.resource.data.members == resource.data.members && // Can't change members
        request.resource.data.ownerUid == resource.data.ownerUid; // Can't change owner

      allow delete: if false; // Never allow couple deletion from client

      // PROFILES Subcollection
      match /profiles/{profileId} {
        allow read: if isCoupleMember(coupleId);
        allow write: if isCoupleMember(coupleId) && isOwner(profileId);
      }

      // MESSAGES Subcollection
      match /messages/{messageId} {
        allow read: if isCoupleMember(coupleId);
        allow create: if isCoupleMember(coupleId) && validMessage();
        allow update: if isCoupleMember(coupleId) && (
          (
            request.auth.uid == resource.data.sender &&
            request.resource.data.sender == resource.data.sender
          ) ||
          isReadReceiptUpdate()
        );
        allow delete: if false; // Use soft delete with deletedAt field
      }

      // TODO CATEGORIES Subcollection
      match /todoCategories/{categoryId} {
        allow read: if isCoupleMember(coupleId);
        allow create: if isCoupleMember(coupleId) &&
          request.resource.data.createdBy == request.auth.uid;
        allow update: if isCoupleMember(coupleId);
        allow delete: if isCoupleMember(coupleId);
      }

      // Sort configuration
      match /todoCategoriesSort/{doc} {
        allow read, write: if isCoupleMember(coupleId);
      }

      // TODO ITEMS Subcollection
      match /todoItems/{itemId} {
        allow read: if isCoupleMember(coupleId);
        allow create: if isCoupleMember(coupleId) &&
          request.resource.data.createdBy == request.auth.uid;
        allow update: if isCoupleMember(coupleId);
        allow delete: if isCoupleMember(coupleId);
      }

      // MEMORIES Subcollection
      match /memories/{memoryId} {
        allow read: if isCoupleMember(coupleId);
        allow create: if isCoupleMember(coupleId) &&
          request.resource.data.uploadedBy == request.auth.uid;
        allow update: if isCoupleMember(coupleId);
        allow delete: if isCoupleMember(coupleId);
      }

      // MILESTONES Subcollection
      match /milestones/{milestoneId} {
        allow read: if isCoupleMember(coupleId);
        allow write: if isCoupleMember(coupleId);
      }

      // LOCATIONS Subcollection
      match /locations/{locationUserId} {
        allow read: if isCoupleMember(coupleId);
        allow write: if isCoupleMember(coupleId) && isOwner(locationUserId);
      }

      // Location History (optional)
      match /locationHistory/{historyId} {
        allow read: if isCoupleMember(coupleId);
        allow create: if isCoupleMember(coupleId) &&
          request.resource.data.userId == request.auth.uid;
        allow update, delete: if false;
      }

      // NOTIFICATIONS Subcollection
      match /notifications/{notificationId} {
        allow read: if isCoupleMember(coupleId) &&
          (resource.data.recipientId == request.auth.uid ||
           resource.data.senderId == request.auth.uid);
        allow create: if isCoupleMember(coupleId);
        allow update: if isCoupleMember(coupleId) &&
          resource.data.recipientId == request.auth.uid; // Only recipient can mark as read
        allow delete: if false;
      }
    }

    // INVITES Collection - special handling
    match /invites/{inviteCode} {
      // Only allow creation by authenticated users
      allow create: if isSignedIn() &&
        request.resource.data.ownerUid == request.auth.uid &&
        request.resource.data.code == inviteCode;

      // No direct read/update/delete from client - use Cloud Functions
      allow read, update, delete: if false;
    }
  }
}
